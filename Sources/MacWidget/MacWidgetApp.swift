// ============================================================================
// MacWidgetApp.swift - 應用程式入口點
// ============================================================================
// 這個檔案是整個 Mac 應用程式的「入口」，就像一本書的封面和目錄
// 它負責：
// 1. 定義應用程式的基本結構
// 2. 設定視窗（window）的特殊行為，讓它看起來像桌面小工具
// ============================================================================

// 匯入必要的框架
import SwiftUI  // Apple 的現代化 UI 框架
import AppKit   // macOS 專用的應用程式框架，提供視窗管理等底層功能

// ============================================================================
// MacWidgetApp 結構 - 應用程式主體
// ============================================================================
// 【@main 說明】
// @main 是一個標記，告訴編譯器：「這裡是程式的起點」
// 就像 C 語言的 main() 函式，或 Python 直接執行的入口
// 程式執行時會從這裡開始
//
// 【App 協定說明】
// : App 代表這個結構遵守 App 協定
// 遵守 App 協定意味著它必須定義 body 屬性來描述應用程式的場景
// ============================================================================
@main
struct MacWidgetApp: App {
    
    // ========================================================================
    // 【應用程式代理】
    // @NSApplicationDelegateAdaptor 是一個橋接器，讓我們可以使用舊式的 AppKit 代理模式
    //
    // 【為什麼需要這個？】
    // SwiftUI 是比較新的框架，有些視窗的進階設定（如透明背景）
    // 需要透過舊的 AppKit 框架來完成
    // 這個 adaptor 讓新舊兩種框架可以一起工作
    //
    // 【代理模式（Delegate）說明】
    // 代理是一種設計模式，讓物件把某些事情「委託」給另一個物件處理
    // 例如：應用程式啟動完成時，系統會通知 AppDelegate 來處理
    // ========================================================================
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    // ========================================================================
    // 【body 屬性】- 應用程式的場景定義
    // some Scene 代表回傳「某種場景」，由編譯器推斷具體型別
    // Scene（場景）是 SwiftUI 中管理視窗的抽象概念
    // ========================================================================
    var body: some Scene {
        
        // ====================================================================
        // WindowGroup - 視窗群組
        // 這是 SwiftUI 定義視窗的標準方式
        // WindowGroup 可以建立多個相同內容的視窗（但我們這個程式只用一個）
        // ====================================================================
        WindowGroup {
            // 視窗的內容是我們定義的 ContentView
            ContentView()
                // 設定背景為透明
                // Color.clear 代表完全透明的顏色
                .background(Color.clear)
        }
        // 隱藏標題列
        // .hiddenTitleBar 讓視窗沒有傳統的標題列（那個有紅黃綠按鈕的部分）
        // 這樣視窗看起來更像桌面小工具，而不是傳統的應用程式視窗
        .windowStyle(.hiddenTitleBar)
    }
}

// ============================================================================
// AppDelegate 類別 - 應用程式代理
// ============================================================================
// 【類別繼承說明】
// NSObject：所有 Objective-C 類別的基礎類別（歷史因素，AppKit 需要這個）
// NSApplicationDelegate：應用程式代理協定，定義了應用程式生命週期的回呼函式
//
// 【為什麼用 class 不用 struct？】
// NSApplicationDelegate 協定要求必須是 class（類別），而不是 struct（結構）
// 這是因為 AppKit 是用 Objective-C 寫的，有一些特定的要求
// ============================================================================
class AppDelegate: NSObject, NSApplicationDelegate {
    
    // ========================================================================
    // 【應用程式啟動完成回呼】
    // 當應用程式完成啟動、準備好顯示畫面時，系統會自動呼叫這個函式
    // 這是設定視窗外觀的最佳時機
    //
    // notification：包含啟動相關資訊的通知物件（這裡我們不使用它）
    // ========================================================================
    func applicationDidFinishLaunching(_ notification: Notification) {
        
        // ====================================================================
        // 【取得視窗物件】
        // NSApplication.shared：取得這個應用程式的單例物件
        // .windows：這個應用程式的所有視窗列表
        // .first：取得第一個視窗（我們只有一個視窗）
        //
        // if let ... ：這是 Swift 的「可選綁定」語法
        // 意思是：如果視窗存在（不是空值），就把它綁定到 window 變數並執行大括號裡的程式碼
        // 這是一種安全的空值處理方式，避免程式因為空值而崩潰
        // ====================================================================
        if let window = NSApplication.shared.windows.first {
            
            // ================================================================
            // 【視窗透明設定】
            // 讓視窗變成透明，這樣就只會顯示我們的 UI 內容
            // ================================================================
            
            // isOpaque = false：設定視窗不是「不透明」的（雙重否定 = 視窗可以透明）
            window.isOpaque = false
            
            // backgroundColor = .clear：設定背景顏色為透明
            window.backgroundColor = .clear
            
            // hasShadow = false：移除視窗陰影
            // 一般視窗都有陰影，移除後看起來更像桌面小工具
            window.hasShadow = false
            
            // ================================================================
            // 【視窗層級設定】
            // level = .floating：設定視窗為「浮動」層級
            // 這讓視窗永遠顯示在其他一般視窗的上面
            // 就像便利貼一樣「黏」在桌面上
            // ================================================================
            window.level = .floating
            
            // ================================================================
            // 【視窗樣式設定】
            // ================================================================
            
            // 插入「全尺寸內容視圖」樣式
            // 這讓我們的內容可以延伸到標題列區域
            window.styleMask.insert(.fullSizeContentView)
            
            // 讓標題列變透明（與前面的 .hiddenTitleBar 搭配）
            window.titlebarAppearsTransparent = true
            
            // 允許透過拖曳視窗背景來移動視窗
            // 通常只能拖曳標題列，設定這個後可以點擊視窗任何地方來移動
            // 這對沒有標題列的視窗很重要
            window.isMovableByWindowBackground = true
            
            // ================================================================
            // 【隱藏標準視窗按鈕】
            // 標準視窗按鈕是指左上角的紅黃綠三個圓形按鈕：
            // - 紅色（關閉按鈕）：關閉視窗
            // - 黃色（最小化按鈕）：將視窗最小化到 Dock
            // - 綠色（縮放按鈕）：放大視窗或進入全螢幕
            //
            // 因為我們要讓視窗看起來像桌面小工具，所以把這些按鈕都隱藏起來
            // 使用者可以透過 Dock 圖示或 Command+Q 來關閉程式
            // ================================================================
            
            // standardWindowButton(.closeButton)：取得關閉按鈕
            // ?.isHidden = true：問號代表如果按鈕存在就隱藏它（安全的空值處理）
            window.standardWindowButton(.closeButton)?.isHidden = true
            
            // 隱藏最小化按鈕
            window.standardWindowButton(.miniaturizeButton)?.isHidden = true
            
            // 隱藏縮放按鈕
            window.standardWindowButton(.zoomButton)?.isHidden = true
        }
    }
}
